# Function Store - このシステムが生む価値

**最終更新**: 2026-02-19

---

## 解決する課題：AIエージェント時代の「車輪の再発明」

AIエージェント（Cursor / Cline / Claude Code）は、毎回ゼロからコードを生成する。
S3アップロード、JWT認証、PDFパース、CSVバリデーション -- 同じロジックを何度も生成し、何度もデバッグする。

これは3つの資源を浪費している:

| 浪費される資源 | 具体例 |
|:---|:---|
| **時間** | 同じ関数を毎回30分かけて生成・検証する |
| **トークン** | 1回の生成に数千トークン消費。月に同じ関数を10回生成すれば数万トークンの無駄 |
| **品質** | 毎回微妙に異なるコードが生まれ、バグの温床になる |

> **Function Storeは、この「生成→検証→廃棄」のサイクルを「生成→蓄積→再利用」に変える。**

---

## 定量的な価値

### 1回の再利用で節約できるもの

| 指標 | 再生成（従来） | 再利用（Function Store） | 削減率 |
|:---|:---|:---|:---|
| 所要時間 | 15-30分 | 10秒（search + install） | **97%** |
| トークン消費 | 2,000-5,000 tokens | 0 tokens | **100%** |
| デバッグリスク | 毎回発生 | ゼロ（検証済みコード） | **100%** |

### 蓄積効果（複利で効く）

```
関数10個蓄積 → 月に 5時間 節約
関数50個蓄積 → 月に 20時間 節約
関数100個蓄積 → もはや「自分専用のstdlib」
```

蓄積すればするほど、新規プロジェクトの立ち上げが速くなる。
関数100個のライブラリを持つ開発者と、毎回ゼロから書く開発者では、生産性に**数倍の差**が出る。

---

## 定性的な価値

### 1. 知識の永続化

コードは書き捨てられるが、Function Storeに保存された関数は**消えない**。
プロジェクトが終わっても、チームが変わっても、自分の「正解のコード」は残り続ける。

- gitの奥底に埋もれた過去のコードを探す必要がない
- 「あの時書いたS3アップロードの関数、どこだっけ？」が `search_functions("S3 upload")` で即解決

### 2. 品質の自動進化

保存時に Quality Gateが自動で走る。
良いコードの検索優先度が上がる。

```
保存 → 品質スコア付与 -> 検索結果をコードの信頼度で操作
```

時間が経つほど、ライブラリ全体の品質が上がり続ける。

### 3. AIエージェントとの相乗効果

Function StoreはMCPサーバーとして動作する。
つまり、AIエージェントが**自律的に**関数を検索・取得・活用できる。

```
従来:  人間が過去のコードを探す → コピペ → エージェントに渡す
今後:  エージェントが自分でFunction Storeを検索 → 即座にinstall → 開発継続
```

人間の介在なしに、エージェントが自分の知識ベースを活用する。
これは「AIエージェントに記憶を与える」ことに等しい。

---

## 戦略的な価値

### ポートフォリオとしての Function Store

| フェーズ | アクション | 得られるもの |
|:---|:---|:---|
| Step 1 | 自分が毎日使う最強のツールを作る | 開発生産性の向上 |
| Step 2 | GitHubにOSSとして公開する | 技術力の証明・ポートフォリオ |
| Step 3 | スターと実績が集まる | キャリア上の信用資産 |

Function Store自体が「自分はこういうものを設計・実装できる人間だ」という証明になる。

### 技術スタックが証明するスキル

このシステムを構築した時点で、以下の技術力を**実装レベルで**証明できる:

- **MCP Protocol**: AIエージェント時代の標準プロトコル設計
- **Vector Search**: Embeddingを使ったセマンティック検索の実装
- **DuckDB**: 分析用OLAPデータベースの実践的活用
- **Google AI API**: Gemini / Gemma の統合（Embedding + LLM）
- **静的解析パイプライン**: Ruff / Mypy / Black の自動化
- **Python設計力**: レイヤードアーキテクチャ、非同期処理、品質ゲート

---

## コスト構造：ゼロリスク

| 項目 | コスト |
|:---|:---|
| サーバー代 | 0円（ローカル完結） |
| API費用 | 0円（Google AI 無料枠） |
| 運用コスト | 0円（自分のPCで動く） |
| 維持管理 | 最小（DuckDBファイル1つ） |

**失うものは何もない。得るものは、時間と品質と実績。**

---

## Before / After

### Before（従来のワークフロー）

```
新しいプロジェクト開始
  → 「S3アップロード関数が必要だな」
  → AIエージェントに生成させる（3,000トークン消費、15分）
  → デバッグ（10分）
  → 動いた。次のプロジェクトでまた同じことをする。
```

### After（Function Store導入後）

```
新しいプロジェクト開始
  → AIエージェント: search_functions("S3 upload")
  → スコア0.94で "s3-uploader" がヒット
  → install_function("s3-uploader", "./utils/")
  → 10秒で完了。検証済みコードがプロジェクトに注入される。
```

---

## まとめ

Function Storeは「ただの便利ツール」ではない。

- **開発者の知識を資産化する仕組み**
- **AIエージェントに記憶を与えるインフラ**
- **技術力を証明するポートフォリオ**

この3つの価値が、コストゼロで手に入る。

> 作らない理由がない。